# Git flow의 개념, 그리고 문제점

우리는 코드를 관리하기 위해서 Git을 사용합니다.

인터넷에서 Git은 다음과 같이 정의됩니다.

> Git이란 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템, 또는 그런 명령어.

맞는 말입니다. 특히나 요즘 개발자라면 모르는 사람이 없는 `Github` 뿐만 아니라 `BitBucket`, `Gitlab` 등이 우리가 깃을 좀 더 다루기 수월하게, 그리고 배포를 좀 더 쉽게 만들어주고 있죠.

서론은 여기까지 하고, 이 글의 주제인 **Git-Flow**란 무엇이고, 어떻게 사용하는가에 따라서 알아봅시다.



## 그래서 Git-Flow가 뭔데?

Git은 기본적으로 여러 명의 사용자가 협업하기 위한 시스템입니다. Git-Flow는 그 시스템 내에 존재하는 방법론입니다. 여러 전략 중의 하나일 뿐이죠. Git이 활성화 되는 시기에 **`Vincent Driessen`** 이라는 사람이 고안해냈다고 합니다. 기본적으로 이 방법론은 다음과 같은 브랜치를 들고갑니다.

- master (또는 main)
- develop
- feature
- release
- hotfix

어찌보면, 브랜치명들이 정말 익숙합니다. **Git-Flow**를 제대로 모르는 사람들도 명칭 자체는 익숙한걸 보니, Git-Flow으로부터 많은 방법론들이 전파되었다고 생각할 수도 있겠군요.

위 브랜치명들을 보시면 아시다시피, 직관적입니다. 그리고 협업을 하기에 정말 효율적인 기능들을 가지고 있군요. 이해가 안 가시면, 사진과 함께 살펴봅시다.

<img src="https://techblog.woowahan.com/wp-content/uploads/img/2017-10-30/git-flow_overall_graph.png" width="600">

Git-Flow를 설명할 때, 그냥 이 사진이 보통 쓰입니다. 그만큼 이해하기에 정말 적합한 사진이죠. 먼저, 위 방법론에서 `main` 과 `develop` 브랜치는 베이스로 항상 존재합니다. 정말 중요한 존재죠.

> `master` 브랜치라고 부르지 않는 이유는 다들 아시죠?

`main` 은 말그대로 배포용 브랜치입니다. 실제 서비스에 배포될 코드를 가지고 있죠. `develop` 은 말 그대로 개발용입니다. 위에서 이 두 브랜치가 가장 중요하다고 말했었죠. 전자는 말할 것도 없지만, `develop` 은 왜 중요할까요? 바로, 우리가 개발하는 거의 모든 작업들이 합쳐지는 곳이기 때문이죠.

그렇기때문에, 가장 많이 충돌이 나는 곳이구요. 만약 `develop` 브랜치에서 2명이서 작업하다가 conflict 난다면? 3명이서 난다면..? 5명...? 정말 끔찍하군요. 이제 Git-Flow를 사용할 차례입니다.

기본적으로 `develop` 브랜치에서부터 시작됩니다. 자, 우리 개발자들은 열심히 개발을 해야겠죠? 하지만 그 전에, 충돌의 최소화와 기능의 책임화를 극대화시키기 위해서 우리는 `feature` 브랜치를 사용할 겁니다. 이 브랜치가 만들어지는 조건은 아마 여러가지가 있겠죠? 네, 열심히 개발을 해서 `feature` 에서 `develop` 으로 코드를 합칠겁니다.

- ```
  feature => develop
  ```

  - 웬만해서는 `Squash` 를 사용하고, 브랜치를 제거해줍니다.
  - 제거할 수 없는 상황이라면 `Rebase` 를 하고, 작업을 지속해줍니다.

이렇게 기능들이 `develop` 브랜치에 보이고 있습니다. 이제 테스트를 거치고 싶군요! 또는 QA를 진행하고 싶습니다. 이 때, 저희는 바빠서 계속 `develop` 브랜치에 개발을 진행해야 해요. 어떻게 할까요?

이럴 때 사용하는 것이 `release` 브랜치입니다.

- ```
  develop => release
  ```

  - 👨‍🎓: QA가 완료될 때까지 해당 릴리즈를 수정할께요!
  - 👩🏻‍🌾: 수정한 코드는 `develop` 에 함께 최신화 진행하겠습니다.
  - 👩🏻‍🌾: 테스트서버는 `release` 브랜치를 바라봐 주시면 됩니다~

이제 QA가 완료되고, 배포 승인이 떨어졌습니다! 배포를 한 번 진행해볼까요?

- ```
  release => main
  ```

  - `Squash` 를 사용하여 `main` 브랜치로 머지하고, 브랜치를 제거해줍니다.

앗! 갑작스럽게 수정해야할 문제가 있어요, 핫픽스를 사용할 차례입니다. 보통 긴급수정은 이미 배포한 실서비스에서 빠르게 문제 처리해야할 상황입니다. 그렇기에, 이번에는 `develop` 브랜치가 아닌, `main` 브랜치에서 `hotfix` 브랜치를 만들어줍니다. 그리고 한 번 문제를 수정해보도록 하죠.

- ```
  hotfix => main
  ```

  - 👩🏻‍🌾: 긴급수정 사항을 `main` 브랜치에 합치는거 당연한 일입니다.
  - 👩🏻‍🌾: 그치만, `main` 이 전부 일까요?

- ```
  hotfix => develop
  ```

  - 긴급 수정사항을 현재 개발 중인 `develop` 브랜치에도 머지해줍시다.

각 브랜치에 합칠 때에는 rebase를 해도 되고, merge를 해도 됩니다.

하하, 벌써 Git-Flow의 모든 것을 설명하였군요. 사실 여기서 말한 것들 외에도 실무에 적용하려면 여러가지 생각할거리가 많습니다. 예로 들어볼까요?

- 👨🏻‍💼: 코드가 충돌났을 때에는 어떻게 처리하나요?
- 👨🏻‍🏭: 이슈는 어떤 기준으로 관리하나요?
- 👷‍♀️: 개발자는 나 혼잔데, 이렇게까지 해야돼나요?

음.. 여러가지 문제점들이 존재하군요. 정말 복잡합니다. 정말 이게 편한가요? 꼭 필요한가요?? 저는 항상 이런 질문을 속으로 대답하려고 하고 있습니다. 어렵지만요 하하

## 그래서 편해?

솔직히 편하다고는 장담하지 못합니다. 당연히 혼자서 개발할 때 제일 편한건 `main` 브랜치 하나에서 개발하는 것이 가장 심플하죠. 그렇다면 왜 이렇게 복잡한(?) 구조로 코드를 관리하나요?

확실히 **Git-Flow**는 단일 개발보다, 다수의 개발자들이 사용하기에 적합한 방법론입니다. Git의 개념과 맞게 작업을 조율하기 쉽기때문이죠. 다수가 하나의 어플리케이션을 개발할 때, 끊김없이 지속될 수 있는 모델이기도 하구요. 그렇다고 완벽한 방법은 아닙니다. 언제든지 개발 상황에 맞게 전략을 재편성하는 것이 최고의 방법이죠.

저 같은 경우에는 **Git-Flow**를 택했지만, 완전하게 받아들이지는 않았습니다. 1명 또는 2명이서 진행하기에는 살짝 번거로운 감이 있었기 때문에, 몇 가지는 skip했었죠. 그리고 그 때에는 Git에 대해서 정확한 역할을 알지 못했기 때문에 ㅎㅎ... 지금과는 또 다르죠.

## 브랜치 전략은 팀원과 상의해라

결국 브랜치 전략은 협업 전략입니다. 그렇기에 아무리 혼자 열심히 만들어도 상대방이 써주질 않으면 그만입니다. 같이 상의해보세요. 그리고, 전략을 수정해나가세요.



# Git flow의 문제점

## 1. develop, main 브랜치 간의 동기화 문제

Git-flow에서 `develop`, ` main`(구 master) 브랜치를 제외한 모든 브랜치는 **임시적인 브랜치**로, 자신의 역할을 다하면 삭제되게 되어 있습니다. Git-flow의 그림을 보면 알겠지만 어느 정도 개발을 마친 후, `develop → main` 병합 과정이 이루어질 때, develop 브랜치가 직접 main 브랜치로 머지되는 것이 아닌 한단계를 거쳐 `develop -> release-* -> main` 형식으로 가게 되죠.

프로젝트의 규모가 커지고 복잡성이 증가해진다면, 저렇게 하는게 좋겠지만 이걸로 인한 가장 큰 문제는 **설령 develop과 main의 코드 상태가 완전히 똑같은 상태일지라도, 이 둘은 Commit 기록 자체가 다르기 때문에 서로 다른 코드 상태라고 인식**된다는 점이다.

대표적으로 예를 들면 **두 브랜치가 완전히 똑같은 상태임에도 develop → main으로 직접 PR을 날리면 아무런 변화가 없어도 PR이 가능해지고 Merge가 가능하다는게 문제**입니다. 심지어 이것마저도 일반 Merge Commit이 아닌 Squash Commit을 날리면 새로운 커밋으로 취급이 되어 동기화가 안되죠.

<img src="https://user-images.githubusercontent.com/29897277/182574384-fe665118-f8ec-4ec7-9793-134e97a01ece.png" width="500">

**이러한 텅 빈 Merge Commit을 날려야만 비로소 develop과 main Branch의 상태가 똑같다고 인식**이 되게 됩니다.

즉, 결론적으로 Repo의 기준이 되는 **`develop`**과 **`main`** 브랜치는 서로 동기화가 가능하도록 하자는 것이다. **그렇지 않으면 우리는 `develop`과 `main` 브랜치가 서로 같은 코드 상태라는 걸 우리의 머리 속에 기억하고 있어야 합니다. 코드가 똑같은 것과 전혀 상관없이 말이죠**.

## 2. 대체 무슨 Merge를 해야 돼?

`Github`에서 `pull request`시 선택할 수 있는 `merge`방식이 3가지가 있다.

- **Merge Commit (일반 머지)**
- **Squach Merge (스쿼시)**
- **Rebase Merge (리베이스)**

각각에 대한 세부 설명은 [여기](https://velog.io/@viiviii/Git-pull-request-시-merge-종류)를 참고.

<img src="https://user-images.githubusercontent.com/29897277/182575205-07f95bb3-db87-4975-bfeb-c08a2ab39153.png" width="500">

Git flow에서 제공하는 그림의 특징상 Rebase Merge는 아닐 것이라고 추측은 해볼 수 있겠지만, 그렇다고 Git flow에서 정확하게 무슨 형태의 머지를 하라는 건지 정의가 되어있지는 않습니다. 제가 지적하는 것은 이러한 모호함입니다.

이는 기존의 Git의 기능 만으로는 기본적으로 Squash and Merge라는 기능이 존재하지 않기 때문에 Git flow에서 이러한 것들을 언급하지 않는 것이라 추측해볼 수 있습니다. 하지만 저희는 다양한 기능을 가진 Github에서 작업하는 만큼 그에 맞게 더 다양한 고민을 해보며 효율적으로 작업을 수행해볼 수 있을 것 입니다.

## 3. develop 브랜치를 기반으로 설계해야 한다

개발 프로젝트를 진행할 때에 있어, develop을 default bransh로 잡고 설계해야 한다고 생각했습니다. 그 이유는,

- develop은 stable하지 않을 뿐, 높은 확률로 해당 프로젝트의 최신 코드 상태를 유지한다.
- 개발자가 가장 많이 상호작용하는 브랜치이며, PR을 받든 PR을 날리든 대부분의 작업은 develop과 연관되어 있다.

> 즉, 이게 아니라 이렇게 하자는 것 입니다.

<img src="https://user-images.githubusercontent.com/29897277/182576344-8abc69e8-9c56-4eb6-a2d1-6d178fc7686f.png" width="500">

## 4. 2중 Merge, 그리고 Release 브랜치

Git flow의 Merge 과정 중에는 굉장히 까다로운 브랜치가 2개 존재합니다. (`release`, `hotfix`)

![image](https://user-images.githubusercontent.com/29897277/182577679-9005f8a5-6238-47fd-a50b-838cd8538644.png)

각기 다른 브랜치에 2중으로 merge를 하는 작업은 굉장히 까다로울 수 있습니다. 두 타겟 브랜치의 코드 형상이 이미 달라져 버릴 수 있기 때문이죠. 그럼에도 이걸 해야하는 이유는 **영구 브랜치인 `develop`, `main`에 일관적으로 수정사항을 반영해주기 위해서입니다. 현재 develop과 main의 코드 상태가 완전히 일치한다면 어렵지 않게 머지가 가능하겠지만, develop이 선행 개발이 더 진행된 상태라면 그때부터 꽤나 까다로워 집니다**.

hotfix의 같은 프로세스상 불가피한 상황이 있다는 점도 인정합니다. 하지만 **2중 merge로 인해 만약 코드 상태가 같았다고 하더라도 `develop`과 `main` 브랜치의 동기화 상태가 깨져버리게 된다는 문제**가 존재합니다.

설령 이 패치로 인해서 완전히 코드의 상태가 같아졌다고 하더라도, 서로 다른 Merge commit이 생성되기 때문입니다. 

> 거기에 더해 release 브랜치는 포지션도 정말 애매해요..

release 브랜치가 정말 모두에게 필요할까? 라는 의문을 지울수가 없었습니다. `release` 브랜치는 `develop`에서 일부 기능을 선행하여 디테일을 잡고 배포하는 계획 등을 위해 사용될 수 있습니다.

예를 들어 `A`, `B`, `C` 기능이 `develop` 브랜치에 올라왔거나 곧 올라올 계획이 있지만 현재 버전에서는 `A`, `B`만 main으로 올릴 계획일 때, 즉 계속해서 변화하는 `develop` 브랜치를 `release` 브랜치로 격리시키기 위해 존재합니다.

여기서 생기는 단점은 위에서 언급한 두 타겟 브랜치 간의 동기화가 깨진다는 점도 있지만, 가장 큰 단점으로 merge 과정이 다소 번거로워진다는 점도 존재합니다.

<img src="https://user-images.githubusercontent.com/29897277/182802432-65c865ac-cac2-4d50-93db-4367f66523ae.png" width="250">

`release` 브랜치는 기능 개발 브랜치가 아니기에 bugfix를 비롯한 여러 잔처리 작업만을 허용하지만, 이 모든 변화 과정 또한 develop에 계속 갱신을 시켜주어야 한다는 것입니다. **1번이 아니라 계속 말이죠.**

여기서 저는 이렇게 하면서 까지 `release` 브랜치의 역할이 필수 불가결 한가? 라는 생각이 들게 되었습니다.

그렇다고 IMFlow에서 release 브랜치를 완전히 버리자는 건 아니고, 역할과 제약을 줄인 상태로 프로세스를 바꿔보기로 했습니다.

## 결론

Git-flow를 보고 IMFlow 전략을 세우면서 개선하고자 하는 점은 다음과 같습니다.

- 영구 브랜치인 `develop`과 `main`은 가능한 한 커밋 히스토리가 동기화되어 있는게 좋다.

  - 그래야 관리가 쉽다.
  - 물론 여기서의 동기화란, `develop → main`을 의미한다. `main → develop`은 지켜지지 않아도 무관하다.

- develop 브랜치에 들어왔다는 것은 테스트가 완료되고 언제든 배포해도 된다는 걸 의미

  한다.

  - 따라서, 통상적인 배포 절차는 `develop -> main` Merge 과정을 통해 수행한다.

- **가능한 한 2중 머지, 지속적인 머지 과정을 프로세스에서 제거하자.**

- **Git-flow에서 정해주지 않은 애매한 것들을 확실하게 정의하자.**